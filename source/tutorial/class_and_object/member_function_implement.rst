C++函数的编译原理和成员函数的实现
=================================

在对象的内存中只包含成员变量，除此之外没有任何其它信息，C++究竟是如何通过对象来调用成员函数的呢？


C++函数的编译
-------------

C++和C的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线\ ``_``\ （不同的编译器有不同的实现）。
例如，\ ``func()``\ 编译后为\ ``func()``\ 或\ ``_func()``\ 。

而C++中的函数在编译时会根据它所在的命名空间、所属的类、以及参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。
这个新的函数名只有编译器知道，对用户是不可见的，对函数重命名的过程叫做\ **名字编码（Name Mangling）**\ ，是通过一种特殊的算法来实现的。

Name Mangling的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。
Name Mangling可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。

.. note::

    除了函数，变量也会经Name Mangling算法产生新的名字。


成员函数的调用
--------------

**成员函数最终被编译为与对象无关的全局函数。**

如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。
如果成员函数中使用到了成员变量怎么办？
\ **C++规定，编译成员函数时要额外添加一个参数（**\ ``this``\ **指针），把当前对象的指针传递进去，通过指针来访问成员变量。**

假设Demo类有两个int型的成员变量，分别是a和b，并且在成员函数display()中使用到了，如下所示：

.. code-block:: cpp

    void Demo::display()
    {
        cout << a << ", " << b << endl;
    }

那么编译后的代码类似于：

.. code-block:: cpp

    void new_function_name(Demo *this)
    {
        // 通过指针来访问a和b
        cout << this->a << ", " << this->b << endl;
    }

使用obj.display()调用函数时，也会被编译成类似下面的形式：

.. code-block:: cpp

    new_function_name(&obj);

**这样，通过对象指针就完成了成员函数和成员变量的关联。**
这与我们从表面上看到的刚好相反，通过对象调用成员函数，不是通过对象找函数，而是通过函数找对象。
这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。

