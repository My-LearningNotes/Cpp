C++构造函数
===========

在C++中，有一种特殊的成员函数，它的名字和类相同，没有返回值，不需要用户显式调用，而是在创建对象时自动执行，这种特殊的成员函数就是\ **构造函数（Constructor）**\ 。

构造函数通常是public的，否则创建对象时无法调用。
当然，设置为private、protected属性也不会报错，但通常是没有意义的。

构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着：

* 不管是声明还是定义，函数名前面都不能出现返回值类型，即使是void也不允许；
* 函数体中不能有return语句。


构造函数的重载
--------------

和普通成员函数一样，构造函数是允许重载的。
一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。

构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。
如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。

构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，例如对成员变量赋值，预先打开文件等。


默认构造函数
------------

如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，不执行任何操作。

一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。
一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成了。

需要注意的一点是，调用没有参数的构造函数也可以省略括号。


// Todo: 各种构造函数
---------------------

Todo


构造函数初始化列表
------------------

**构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量赋值，还可以采用初始化列表。**

.. note::

    在构造函数的函数体中对成员变量赋值，其过程是先创建对象，对象创建完成后再赋值，是分两步完成的。

    而构造函数的初始化列表，是在创建对象的同时初始化成员变量，更加简洁，效率也更高。

Example:

.. code-block:: cpp
    :emphasize-lines: 13

    class Student
    {
    private:
        char *m_name;
        int m_age;
        float m_score;

    public:
        Student(char *name, int age, float score);
    };

    // 使用初始化列表
    Student::Student(char *name, int age, float score) : m_name(name), m_age(age), m_score(score)
    {
        // ...
    }

* 初始化列表可以用于全部成员变量，也可以只用于部分成员变量。
* 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中的声明顺序有关。

Example:

.. code-block:: cpp
    :emphasize-lines: 16 

    #include <iostream>

    using namespace std;

    class Demo
    {
    public:
        Demo(int b);
        void show();

    private:
        int m_a;
        int m_b
    };

    Demo::Demo(int b) : m_b(b), m_a(m_b)
    {}

    void Demo::show()
    {
        cout << m_a << ", " << m_b << endl;
    }

    int main()
    {
        Demo obj(100);
        obj.show();

        return 0;
    }

    // 运行结果：32765，100

在初始化列表中，我们将m_b放在了m_a的前面，看起来是先给m_b赋值，再给m_a赋值，其实不然！
成员变量的赋值顺序由它们在类中的声明顺序决定，在Demo类中，先声明的m_a，再声明m_b，所以构造函数和下面的代码等价：

.. code-block:: cpp

    Demo::Demo(int b)
    {
        m_a = m_b;
        m_b = b;
    }

给m_a赋值时，m_b还未初始化，它的值是不确定的，所以输出的m_a的值是一个奇怪的数字；
给m_a赋值完成后才给m_b赋值，此时m_b的值才是100。

.. attention::

    对成员变量初始化时，如果它们之间有依赖关系，需要注意成员变量的初始化顺序。

    成员变量的初始化顺序是由它们在类中的声明顺序决定的。


初始化const成员变量
*******************

构造函数的初始化列表还有一个很重要的作用：\ **初始化const成员变量**\ 。
初始化const成员变量的唯一方法就是使用构造函数的初始化列表。

.. note::

    因为const成员变量在初始化之后就无法再修改，所以只能在构造函数的时候对其初始化。

